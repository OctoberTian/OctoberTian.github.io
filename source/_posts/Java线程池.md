---
title: Java线程池
thumbnail: /2019/05/17/d3541f2b/zd01.jpg
tags: 线程池
categories: 线程
abbrlink: 2b9621c6
date: 2019-08-10 21:17:20
---

## 前言

线程池的常见问题和创建方式

<!--More-->

## **什么是线程池**？

线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。

如果每个请求都创建一个线程去处理，那么服务器的资源很快就会被耗尽，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。

## 为什么要使用线程池？

创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）

## 线程池有什么作用？

线程池作用就是限制系统中执行线程的数量。

1. 提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。

2. 方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。

## 说说几种常见的线程池及使用场景

### 1. `newSingleThreadExecutor`

创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

### 2. `newFixedThreadPool`

创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

##### 缺点:

`newFixedThreadPool()`在严格上说并不会复用线程，每运行一个`Runnable`都会通过`ThreadFactory`创建一个线程

### 3. `newCachedThreadPool`

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

##### 缺点：

`Executors.newCachedThreadPool()`缺点：大家一般不用是因为`newCachedThreadPool `可以无线的新建线程，容易造成堆外内存溢出，因为它的最大值是在初始化的时候设置为 `Integer.MAX_VALUE`，一般来说机器都没那么大内存给它不断使用。当然知道可能出问题的点，就可以去重写一个方法限制一下这个最大值

### 4. `newScheduledThreadPool`

创建一个定长线程池，支持定时及周期性任务执行。

需要注意的是，只有当任务的执行时间到来时，`ScheduedExecutor` 才会真正启动一个线程，其余时间 `ScheduledExecutor` 都是在轮询任务的状态。

### 5. `newWorkStealingPool`

一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用`cpu`数量的线程来并行执行。

## 开启线程的三种方式？run()和start()方法区别？

`Java`使用`Thread`类代表线程，所有的线程对象都必须是`Thread`类或其子类的实例。`Java`可以用三种方式来创建线程
1）继承`Thread`类创建线程
2）实现`Runnable`接口创建线程
3）使用`Callable`和`Future`创建线程

## new Thread的弊端？

1. 每次`new Thread`新建对象**性能差**。
1. 线程缺乏统一管理，**可能无限制新建线程**，相互之间**竞争**，及可能占用过多系统资源导致死机。
1. 缺乏更多功能，如**定时执行、定期执行、线程中断**。
1. 相比new Thread，Java提供的四种线程池的好处在于：
   1. 重用存在的线程，减少对象创建、消亡的开销，性能佳。
   1. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。
   1. 提供定时执行、定期执行、单线程、并发数控制等功能。

## 线程池中的几种重要的参数

- `corePoolSize`: 就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收

- `maximumPoolSize`: 就是线程池中可以容纳的最大线程的数量

- `keepAliveTime`: 就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，

- `util`: 就是计算这个时间的一个单位。

- `workQueue`: 就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。

- `threadFactory`: 就是创建线程的线程工厂。

- `handler`: 是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。

## 说说线程池的拒绝策略

​    当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务。`RejectedExecutionHandler`接口提供了拒绝任务处理的自定义方法的机会。在`ThreadPoolExecutor`中已经包含四种处理策略。

- `AbortPolicy策略`：该策略会直接抛出异常，阻止系统正常工作。

- `CallerRunsPolicy策略`：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。

- `DiscardOleddestPolicy策略`： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。

- `DiscardPolicy策略`：该策略默默的丢弃无法处理的任务，不予任何处理。

​    除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现`RejectedExecutionHandler`接口即可。

## execute和submit的区别？

​    在前面的讲解中，我们执行任务是用的execute方法，除了execute方法，还有一个submit方法也可以执行我们提交的任务。

这两个方法有什么区别呢？分别适用于在什么场景下呢？我们来做一个简单的分析。

- execute适用于不需要关注返回值的场景，只需要将线程丢到线程池中去执行就可以了。

- submit方法适用于需要关注返回值的场景

## 线程池的关闭

关闭线程池可以调用shutdownNow和shutdown两个方法来实现

- shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。

- shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。

## 初始化线程池时线程数的选择

- 如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。

- 如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。

上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。

## 线程池都有哪几种工作队列

### `ArrayBlockingQueue`

是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。

### `LinkedBlockingQueue`

一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于`ArrayBlockingQueue`。静态工厂方法`Executors.newFixedThreadPool()`使用了这个队列

### `SynchronousQueue`

一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于`LinkedBlockingQueue`，静态工厂方法`Executors.newCachedThreadPool`使用了这个队列。

### `PriorityBlockingQueue`

一个具有优先级的无限阻塞队列。